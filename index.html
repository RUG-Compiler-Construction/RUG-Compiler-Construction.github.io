<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
		<meta http-equiv="X-UA-Compatible" content="IE=9"/>
		<meta name="generator" content="Doxygen 1.9.1"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		<title>ecgl-ast: Table of Contents</title>
		<link href="tabs.css" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="jquery.js"></script>
		<script type="text/javascript" src="dynsections.js"></script>
		<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
		<link href="doxygen.css" rel="stylesheet" type="text/css" />
		<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
	</head>
	<body>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div id="titlearea">
			<table cellspacing="0" cellpadding="0">
				<tbody>
					<tr style="height: 56px;">
						<td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
						<td id="projectalign" style="padding-left: 0.5em;">
							<div id="projectname">ecgl-ast
								&#160;<span id="projectnumber">0.1</span>
							</div>
							<div id="projectbrief">the abstract syntax tree for EGCL</div>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
		<!-- end header part --><!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Table of Contents </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_src_readme"></a></p><ol type="1">
<li><a href="#org6b6656a">FAST README</a></li>
<li><a href="#orgf5fef85">Extensible Ast implementation</a><ol type="a">
<li><a href="#org16f19b0">Tasks</a><ol type="i">
<li><a href="#org7fd1509">Base class for ast node</a></li>
<li><a href="#orgbe4b9d4">Computable interfaces</a></li>
</ol>
</li>
<li><a href="#orgf70f224">Accumulators</a></li>
</ol>
</li>
</ol>
<p><a class="anchor" id="org6b6656a"></a></p>
<h1><a class="anchor" id="autotoc_md1"></a>
FAST README</h1>
<p>The abstract idea of this codebase is that we can treat the node of this ast as a function (polymorphic function). Once we have this abstraction we can then reframe all the section of the compiler (e.g. semantic checking, generation etc.) to just a concatenation of all these functions. The crucial element that we still need though, is a stateful accumulator for this recursion. Given these two abstractions we can now generalized all the different part of the compiler into a recursion with a stateful accumulator. Finally, based on the type of accumulator we can differentiate the singular part. So for example the semantic checking will have a different type of accumulator then the one used by the generation.</p>
<p>Implementation wise, the first abstraction is achieved through an interface and in order to have the possibility to dispatch on the type of the accumulator this interface is templated and it defines a virtual eval function (which takes an accumulator and returns an accumulator) for each type of stateful accumulator. Finally, the accumulator class is templated and it wraps a type. Therefore will be used for all the different section with different wrapped type. Lastly, there are some utils to carry out this recursion. They are referred to as transformers and they transform a sequence of computable. An example of that is the reducer which takes a sequence of computable and returns a single computable which is the composition of the initial sequence.</p>
<p>This was the fast read me the following part will be the final readme but it's not complete yet! Lastly, I wrote some example nodes and some example on how to use this idea (i implemented just for a trivial printing operation!) I defined a <a class="el" href="classPprint.html">Pprint</a> type just to show what is needed in order to implement a struct/class which will behave as aspected when wrapped by an accumulator. The idea for the project, in general, is that we need to define the nodes that we have and then each group can do their task autonomously. The only thing that is need to perform a group task is to define a class/struct like <a class="el" href="classPprint.html">Pprint</a> and then overload for each node an eval function which takes an accumulator of the defined class/struct type.</p>
<p><a class="anchor" id="orgf5fef85"></a></p>
<h1><a class="anchor" id="autotoc_md2"></a>
Extensible Ast implementation</h1>
<p>This codebase defines a class hierarchy and a behavioural interface for the EGCL abstract syntax tree.</p>
<p><a class="anchor" id="org16f19b0"></a></p>
<h2><a class="anchor" id="autotoc_md3"></a>
Tasks</h2>
<p>Once the ast is built several tasks can be carried out with it.</p>
<ol type="1">
<li>Print: pretty print the ast.</li>
<li>Check: perform semantic checking on the ast.</li>
<li>Emit: generate target language code for the ast.</li>
</ol>
<p>The fundamental idea is that each task involves traversing the ast carrying through a stateful accumulator.</p>
<p>For example for pretty-printing the tree is traversed and a string representation is incrementally built, recursively appending the individual parts to an initially empty string.</p>
<p>For semantic checking, the accumulator may be more complex than a string but the idea is the same: each node in the tree will recursively check its children and then check the the correctness of the specific semantics of its node type, while accumulating some descriptor that carries the necessary information to do the checking.</p>
<p><a class="anchor" id="org7fd1509"></a></p>
<h3><a class="anchor" id="autotoc_md4"></a>
Base class for ast node</h3>
<p>The base class <a class="el" href="classAstNode.html" title="AstNode base class for the ast nodes.">AstNode</a> is the starting point to build concrete ast nodes. Besides holding a protected <code>metadata</code> field it just serves as abstraction fan point for the rest of the nodes.</p>
<p>Ideally, each concrete node type will provide its own implementation of each of the above tasks.</p>
<p><a class="anchor" id="orgbe4b9d4"></a></p>
<h3><a class="anchor" id="autotoc_md5"></a>
Computable interfaces</h3>
<p>For each of these tasks, an abstract class (interface) is defined via the <code><a class="el" href="classComputable.html" title="Templated class to extend when defining a task interface.">Computable</a></code> template that establishes the specific type of accumulator for the task, and leaves to concrete classes the implementation of the eval() method.</p>
<p>For example: </p><pre class="fragment">// shortcut for Computable&lt;string&gt;, that is it accumulates string, e.g. for
// pretty printing
class Printable : public Computable&lt;Pprint&gt; {};
</pre><p> defines the Printable interface as something that will produce a string.</p>
<p>Similarly if semantic::CheckerState is a class maintaining the state of the semantic checker appropriately implemented: </p><pre class="fragment">class Checkable : public Computable&lt;semantic::CheckerState&gt; {};
</pre><p> would be the definition of the interface for nodes whose semantics can be checked.</p>
<p>TODO</p>
<p><a class="anchor" id="orgf70f224"></a></p>
<h2><a class="anchor" id="autotoc_md6"></a>
Accumulators</h2>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
		<script src="custom.js"></script>
	</body>
</html>
